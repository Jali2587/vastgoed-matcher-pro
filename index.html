<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸš€ Vastgoed Matcher Pro AI - Complete + Optimized</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Firebase Scripts -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    
    <!-- CSV Parser -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <!-- Firebase Configuration -->
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyD5daKmpLUMcxmOiAXkPkmiJrZ5kDG3HMo",
            authDomain: "vastgoed-matcher-mvp.firebaseapp.com",
            projectId: "vastgoed-matcher-mvp",
            storageBucket: "vastgoed-matcher-mvp.appspot.com",
            messagingSenderId: "785479169064",
            appId: "1:785479169064:web:eb328415e1277241df311d"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();
        
        console.log('ðŸ”¥ Firebase initialized successfully!');
    </script>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback, memo } = React;
        
        // ðŸš€ PERFORMANCE: Optimized Icon components
        const PlusIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('path', { d: 'M12 5v14M5 12h14' })));
        
        const UsersIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('path', { d: 'M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2' }), React.createElement('circle', { cx: '9', cy: '7', r: '4' }), React.createElement('path', { d: 'M22 21v-2a4 4 0 0 0-3-3.87M16 3.13a4 4 0 0 1 0 7.75' })));
        
        const BuildingIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('path', { d: 'M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z' }), React.createElement('path', { d: 'M6 12h4h4' }), React.createElement('path', { d: 'M6 20h4h4' }), React.createElement('path', { d: 'M10 4h4' }), React.createElement('path', { d: 'M10 8h4' })));
        
        const StarIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('polygon', { points: '12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26' })));
        
        const FilterIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('polygon', { points: '22,3 2,3 10,12.46 10,19 14,21 14,12.46' })));
        
        const MailIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('path', { d: 'M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z' }), React.createElement('polyline', { points: '22,6 12,13 2,6' })));
        
        const PhoneIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('path', { d: 'M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07a19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z' })));
        
        const MapPinIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('path', { d: 'M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z' }), React.createElement('circle', { cx: '12', cy: '10', r: '3' })));
        
        const EuroIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('path', { d: 'M18.5 6.5a9 9 0 0 0-9 9v0a9 9 0 0 0 9 9M6 12h9' })));
        
        const TrendingUpIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('polyline', { points: '22,7 13.5,15.5 8.5,10.5 2,17' }), React.createElement('polyline', { points: '16,7 22,7 22,13' })));
        
        const CalendarIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('rect', { x: '3', y: '4', width: '18', height: '18', rx: '2', ry: '2' }), React.createElement('line', { x1: '16', y1: '2', x2: '16', y2: '6' }), React.createElement('line', { x1: '8', y1: '2', x2: '8', y2: '6' }), React.createElement('line', { x1: '3', y1: '10', x2: '21', y2: '10' })));
        
        const AlertCircleIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('circle', { cx: '12', cy: '12', r: '10' }), React.createElement('line', { x1: '12', y1: '8', x2: '12', y2: '12' }), React.createElement('line', { x1: '12', y1: '16', x2: '12.01', y2: '16' })));
        
        const LogOutIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('path', { d: 'M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4' }), React.createElement('polyline', { points: '16,17 21,12 16,7' }), React.createElement('line', { x1: '21', y1: '12', x2: '9', y2: '12' })));
        
        const UserIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('path', { d: 'M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2' }), React.createElement('circle', { cx: '12', cy: '7', r: '4' })));
        
        const BrainIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('path', { d: 'M12 2a3 3 0 0 0-3 3 3 3 0 0 0-3 3v1a3 3 0 0 0 3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0 3-3V8a3 3 0 0 0-3-3 3 3 0 0 0-3-3z' })));
        
        const SearchIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('circle', { cx: '11', cy: '11', r: '8' }), React.createElement('path', { d: 'M21 21l-4.35-4.35' })));
        
        const FileTextIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('path', { d: 'M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z' }), React.createElement('polyline', { points: '14,2 14,8 20,8' }), React.createElement('line', { x1: '16', y1: '13', x2: '8', y2: '13' }), React.createElement('line', { x1: '16', y1: '17', x2: '8', y2: '17' }), React.createElement('polyline', { points: '10,9 9,9 8,9' })));
        
        const TargetIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('circle', { cx: '12', cy: '12', r: '10' }), React.createElement('circle', { cx: '12', cy: '12', r: '6' }), React.createElement('circle', { cx: '12', cy: '12', r: '2' })));
        
        const ZapIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('polygon', { points: '13,2 3,14 12,14 11,22 21,10 12,10' })));
        
        const DollarSignIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('line', { x1: '12', y1: '1', x2: '12', y2: '23' }), React.createElement('path', { d: 'M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6' })));
        
        const UserCheckIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('path', { d: 'M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2' }), React.createElement('circle', { cx: '8.5', cy: '7', r: '4' }), React.createElement('polyline', { points: '17,11 19,13 23,9' })));
        
        const AwardIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('circle', { cx: '12', cy: '8', r: '7' }), React.createElement('polyline', { points: '8.21,13.89 7,23 12,20 17,23 15.79,13.88' })));
        
        const SettingsIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('circle', { cx: '12', cy: '12', r: '3' }), React.createElement('path', { d: 'M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z' })));
        
        const EditIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('path', { d: 'M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7' }), React.createElement('path', { d: 'M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z' })));
        
        const TrashIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('polyline', { points: '3,6 5,6 21,6' }), React.createElement('path', { d: 'M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2' }), React.createElement('line', { x1: '10', y1: '11', x2: '10', y2: '17' }), React.createElement('line', { x1: '14', y1: '11', x2: '14', y2: '17' })));

        const PercentIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('line', { x1: '19', y1: '5', x2: '5', y2: '19' }), React.createElement('circle', { cx: '6.5', cy: '6.5', r: '2.5' }), React.createElement('circle', { cx: '17.5', cy: '17.5', r: '2.5' })));

        const ExternalLinkIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('path', { d: 'M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6' }), React.createElement('polyline', { points: '15,3 21,3 21,9' }), React.createElement('line', { x1: '10', y1: '14', x2: '21', y2: '3' })));

        const UploadIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('path', { d: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4' }), React.createElement('polyline', { points: '7,10 12,15 17,10' }), React.createElement('line', { x1: '12', y1: '15', x2: '12', y2: '3' })));

        const DatabaseIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('ellipse', { cx: '12', cy: '5', rx: '9', ry: '3' }), React.createElement('path', { d: 'M21 12c0 1.66-4 3-9 3s-9-1.34-9-3' }), React.createElement('path', { d: 'M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5' })));

        const RefreshIcon = memo(({ size = 20, className = '' }) => React.createElement('svg', { 
          width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: '2', className 
        }, React.createElement('polyline', { points: '23,4 23,10 17,10' }), React.createElement('polyline', { points: '1,20 1,14 7,14' }), React.createElement('path', { d: 'M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15' })));

        const VastgoedInvesteerderMatcher = () => {
          // ðŸš€ PERFORMANCE: Split state for better optimization
          const [user, setUser] = useState(null);
          const [activeTab, setActiveTab] = useState('dashboard');
          const [showAuth, setShowAuth] = useState(true);
          const [isLoadingAI, setIsLoadingAI] = useState(false);
          
          // ðŸš€ PERFORMANCE: Raw data state for deduplication
          const [rawInvestors, setRawInvestors] = useState([]);
          const [rawBrokers, setRawBrokers] = useState([]);
          const [rawDeals, setRawDeals] = useState([]);
          const [rawContacts, setRawContacts] = useState([]);
          const [rawTransactions, setRawTransactions] = useState([]);
          const [rawUsers, setRawUsers] = useState([]);
          
          // UI and interaction state
          const [matches, setMatches] = useState([]);
          const [aiInsights, setAiInsights] = useState({});
          const [contactFilter, setContactFilter] = useState('all');
          const [csvFilter, setCsvFilter] = useState('all');
          
          // Modal and edit state
          const [showAddInvestor, setShowAddInvestor] = useState(false);
          const [showAddDeal, setShowAddDeal] = useState(false);
          const [showAddBroker, setShowAddBroker] = useState(false);
          const [showCommissionEditor, setShowCommissionEditor] = useState(false);
          const [showCsvUpload, setShowCsvUpload] = useState(false);
          const [showConvertModal, setShowConvertModal] = useState(false);
          const [showEditInvestor, setShowEditInvestor] = useState(false);
          const [showEditDeal, setShowEditDeal] = useState(false);
          const [showEditBroker, setShowEditBroker] = useState(false);
          
          // Edit entities
          const [editingInvestor, setEditingInvestor] = useState(null);
          const [editingDeal, setEditingDeal] = useState(null);
          const [editingBroker, setEditingBroker] = useState(null);
          const [editingDealCommission, setEditingDealCommission] = useState(null);
          const [convertingContact, setConvertingContact] = useState(null);
          const [currentTransaction, setCurrentTransaction] = useState(null);
          
          // CSV upload state
          const [csvData, setCsvData] = useState([]);
          const [isUploadingCsv, setIsUploadingCsv] = useState(false);

          // ðŸ”§ DEDUPLICATION: Utility functions
          const deduplicateById = useCallback((array, idField = 'id') => {
            const seen = new Set();
            return array.filter(item => {
              const id = item[idField];
              if (seen.has(id)) return false;
              seen.add(id);
              return true;
            });
          }, []);

          const deduplicateByEmail = useCallback((array) => {
            const seen = new Set();
            return array.filter(item => {
              const email = item.email?.toLowerCase();
              if (!email || seen.has(email)) return false;
              seen.add(email);
              return true;
            });
          }, []);

          // ðŸš€ PERFORMANCE: Memoized deduplicated data
          const investors = useMemo(() => 
            deduplicateById(rawInvestors), [rawInvestors, deduplicateById]
          );
          
          const brokers = useMemo(() => 
            deduplicateById(rawBrokers), [rawBrokers, deduplicateById]
          );
          
          const deals = useMemo(() => 
            deduplicateById(rawDeals), [rawDeals, deduplicateById]
          );
          
          const contacts = useMemo(() => 
            deduplicateById(rawContacts), [rawContacts, deduplicateById]
          );
          
          const transactions = useMemo(() => 
            deduplicateById(rawTransactions), [rawTransactions, deduplicateById]
          );
          
          const users = useMemo(() => 
            deduplicateById(rawUsers), [rawUsers, deduplicateById]
          );

          // ðŸš€ PERFORMANCE: Memoized utility functions
          const getUserById = useCallback((id) => {
            return users.find(u => u.id === id) || { name: 'Onbekend', email: '' };
          }, [users]);

          // ðŸš€ PERFORMANCE: AI call optimization with caching
          const aiCallCache = useMemo(() => new Map(), []);
          
          const callOpenAI = useCallback(async (prompt, type = 'analysis', data = null) => {
            const cacheKey = `${type}-${prompt.substring(0, 50)}`;
            if (aiCallCache.has(cacheKey)) {
              return aiCallCache.get(cacheKey);
            }

            setIsLoadingAI(true);
            
            try {
              const response = await fetch('/.netlify/functions/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt, type, data })
              });
              
              if (response.ok) {
                const result = await response.json();
                setIsLoadingAI(false);
                aiCallCache.set(cacheKey, result.data);
                return result.data;
              }
            } catch (error) {
              console.log('OpenAI API niet beschikbaar, gebruik demo data:', error);
            }
            
            // Enhanced fallback with semantic matching simulation
            await new Promise(resolve => setTimeout(resolve, 800));
            
            const mockResponses = {
              enhanced_matching: {
                semanticScore: 85,
                semanticReasons: [
                  'Sterke match: "stabiele huurinkomsten" â†” "gegarandeerde huurder 5 jaar"',
                  'Perfecte match: "geen renovatie" â†” "turn-key appartement"', 
                  'Goede match: "duurzaamheid belangrijk" â†” "energielabel A"',
                  'Match: "ervaring met appartementen" â†” "luxe appartement complex"'
                ],
                conflictAnalysis: [],
                overallCompatibility: 92,
                pitchRecommendations: [
                  'Benadruk de gegarandeerde huurinkomsten van 5 jaar',
                  'Vermeld turn-key voordeel: direct rendement zonder werk',
                  'Highlight duurzaamheid: energielabel A en lage kosten',
                  'Toon vergelijkbare succesvolle projecten in portfolio'
                ]
              },
              investor_analysis: {
                fullAnalysis: `FinanciÃ«le sterkte: Hoog - Stabiele inkomstenbron via vastgoedbeleggingen

Risicobereidheid: Gemiddeld tot hoog - Ervaren investeerder met diversified portfolio

Marktkennis: Goed - Actief in Nederlandse vastgoedmarkt sinds 2015

Voorkeurssectoren: Residentieel, Commercieel retail

Projectvoorkeur: Turn-key, Renovatie

Investeringsstrategie: Buy-and-hold met focus op cashflow generatie`,
                aiRecommendations: [
                  'Geschikt voor deals met stabiele huurinkomsten en potentieel voor waardestijging',
                  'Voorzichtige beslisser, graag veel informatie vooraf',
                  'Zoekt deals voor Q2-Q3 2024',
                  'Positief over vastgoedmarkt, maar voorzichtig met nieuwe projecten'
                ]
              },
              deal_analysis: {
                fullAnalysis: `Marktpositie: Aantrekkelijk - Locatie in groeiende wijk met goede bereikbaarheid

Project type analyse: Turn-key voordeel - Direct rendement, lagere ontwikkelingsrisico's

Concurrentie analyse: Vergelijkbare panden in de buurt hebben 5-7% rendement

Risicofactoren: Mogelijke leegstand bij huurwisseling, Onderhoudskosten oudere panden

Kansen: Huurverhoging mogelijk door renovatie, Waardestijging door buurtverbetering`,
                aiRecommendations: [
                  'Aanbevolen voor conservatieve tot gemiddelde risico investeerders',
                  'Prijzen in dit gebied stijgen 3-5% per jaar',
                  'Populair bij young professionals en small families',
                  'Positieve ontwikkeling verwacht door infrastructuurprojecten'
                ]
              },
              contact_classification: {
                suggestedType: data?.position?.toLowerCase()?.includes('investment') || 
                               data?.position?.toLowerCase()?.includes('fund') ||
                               data?.position?.toLowerCase()?.includes('capital') ? 'investor' : 
                               data?.position?.toLowerCase()?.includes('broker') ||
                               data?.position?.toLowerCase()?.includes('agent') ||
                               data?.position?.toLowerCase()?.includes('makelaar') ? 'broker' : 'unknown',
                confidence: 0.75,
                reasoning: [
                  'Functietitel analyse gebaseerd op keywords',
                  'Bedrijfsnaam analyse voor type organisatie',
                  'LinkedIn profiel indicatoren'
                ],
                suggestions: [
                  'Verifieer rol via LinkedIn profiel',
                  'Check bedrijfswebsite voor meer context',
                  'Overweeg beide categorieÃ«n als onzeker'
                ]
              }
            };

            setIsLoadingAI(false);
            
            const result = mockResponses[type] || mockResponses.enhanced_matching;
            aiCallCache.set(cacheKey, result);
            return result;
          }, [aiCallCache]);

          // ðŸš€ PERFORMANCE: Enhanced matching algorithm with memoization
          const calculateMatchScore = useCallback((investor, deal) => {
            let score = 0;
            let maxScore = 0;
            let reasoningFactors = [];

            // Budget matching (20%)
            maxScore += 20;
            if (deal.prijs >= investor.minBudget && deal.prijs <= investor.maxBudget) {
              score += 20;
              reasoningFactors.push(`âœ“ Budget perfect match (â‚¬${deal.prijs.toLocaleString()} binnen â‚¬${investor.minBudget.toLocaleString()}-â‚¬${investor.maxBudget.toLocaleString()} range)`);
            } else if (deal.prijs < investor.minBudget) {
              const budgetScore = Math.max(0, 20 - ((investor.minBudget - deal.prijs) / investor.minBudget * 20));
              score += budgetScore;
              reasoningFactors.push(`âš  Deal prijs onder minimum budget (${budgetScore.toFixed(1)}/20 punten)`);
            } else {
              reasoningFactors.push(`âœ— Deal prijs boven maximum budget`);
            }

            // Location matching (15%)
            maxScore += 15;
            let locationScore = 0;
            
            if ((investor.voorkeursLanden || []).some(land => 
              deal.locatie.toLowerCase().includes(land.toLowerCase())
            )) {
              locationScore = 15;
              reasoningFactors.push(`âœ“ Land match gevonden in locatie`);
            } else if ((investor.voorkeursRegio || []).length > 0) {
              locationScore = 8;
              reasoningFactors.push(`~ Regio voorkeur aanwezig`);
            } else {
              locationScore = 5;
              reasoningFactors.push(`~ Geen specifieke locatie eisen`);
            }
            
            score += locationScore;

            // Type matching (15%)
            maxScore += 15;
            if ((investor.vastgoedTypes || []).includes(deal.type)) {
              score += 15;
              reasoningFactors.push(`âœ“ Vastgoed type match (${deal.type})`);
            } else if ((investor.vastgoedTypes || []).length === 0) {
              score += 7;
              reasoningFactors.push(`~ Geen specifieke vastgoed type voorkeur`);
            } else {
              reasoningFactors.push(`âœ— Vastgoed type niet in voorkeuren`);
            }

            // Project type matching (10%)
            maxScore += 10;
            if ((investor.projectTypes || []).includes(deal.projectType)) {
              score += 10;
              reasoningFactors.push(`âœ“ Project type match (${deal.projectType})`);
            } else if ((investor.projectTypes || []).length === 0) {
              score += 5;
              reasoningFactors.push(`~ Geen specifieke project type voorkeur`);
            } else {
              reasoningFactors.push(`âœ— Project type niet in voorkeuren`);
            }

            // Return matching (15%)
            maxScore += 15;
            if (deal.verwachtRendement >= investor.gewenstRendement) {
              score += 15;
              reasoningFactors.push(`âœ“ Rendement boven verwachting (${deal.verwachtRendement}% vs ${investor.gewenstRendement}%)`);
            } else {
              const rendementScore = Math.max(0, 15 - ((investor.gewenstRendement - deal.verwachtRendement) / investor.gewenstRendement * 15));
              score += rendementScore;
              reasoningFactors.push(`âš  Rendement onder verwachting (${rendementScore.toFixed(1)}/15 punten)`);
            }

            // Risk matching (10%)
            maxScore += 10;
            const risicoMatch = {
              'Conservatief': { 'Laag': 10, 'Gemiddeld': 6, 'Hoog': 2 },
              'Gemiddeld': { 'Laag': 8, 'Gemiddeld': 10, 'Hoog': 7 },
              'Agressief': { 'Laag': 5, 'Gemiddeld': 8, 'Hoog': 10 }
            };
            const risicoScore = risicoMatch[investor.risicoprofiel]?.[deal.risico] || 0;
            score += risicoScore;
            reasoningFactors.push(`${risicoScore >= 8 ? 'âœ“' : 'âš '} Risico match (${investor.risicoprofiel} profiel, ${deal.risico} risico)`);

            // Semantic matching (15%)
            maxScore += 15;
            let semanticScore = 0;
            let semanticReasons = [];
            
            const investorText = [
              investor.investmentMotivatie || '',
              investor.bijzonderheden || '',
              investor.locatieDetails || ''
            ].join(' ').toLowerCase();
            
            const dealText = [
              deal.beschrijving || '',
              deal.bijzonderheden || ''
            ].join(' ').toLowerCase();

            // Semantic keyword matching
            const semanticMatches = [
              { investor: ['stabiel', 'huurinkomst', 'gegarandeerd'], deal: ['gegarandeerd', 'huurder', 'corporatie'], points: 5, desc: 'Stabiele huurinkomsten match' },
              { investor: ['turn-key', 'geen renovatie', 'kant-en-klaar'], deal: ['turn-key', 'kant-en-klaar', 'direct'], points: 4, desc: 'Turn-key voorkeur match' },
              { investor: ['duurzaam', 'energie', 'milieu'], deal: ['energielabel', 'duurzaam', 'zonnepanel', 'warmtepomp'], points: 3, desc: 'Duurzaamheid match' },
              { investor: ['student', 'universiteit'], deal: ['student', 'universiteit', 'campus'], points: 3, desc: 'Studenten segment match' },
              { investor: ['centrum', 'bereikbaar', 'transport'], deal: ['centrum', 'metro', 'transport', 'bereikbaar'], points: 2, desc: 'Locatie bereikbaarheid match' }
            ];

            semanticMatches.forEach(match => {
              const investorHasKeywords = match.investor.some(keyword => investorText.includes(keyword));
              const dealHasKeywords = match.deal.some(keyword => dealText.includes(keyword));
              
              if (investorHasKeywords && dealHasKeywords) {
                semanticScore += match.points;
                semanticReasons.push(`âœ“ ${match.desc}`);
              }
            });

            // Conflict detection
            const conflicts = [
              { investor: ['geen renovatie', 'turn-key'], deal: ['renovatie', 'opknappen'], desc: 'Renovatie conflict' },
              { investor: ['centrum'], deal: ['buitenwijk', 'periferie'], desc: 'Locatie voorkeur conflict' }
            ];

            conflicts.forEach(conflict => {
              const investorWants = conflict.investor.some(keyword => investorText.includes(keyword));
              const dealOffers = conflict.deal.some(keyword => dealText.includes(keyword));
              
              if (investorWants && dealOffers) {
                semanticScore -= 3;
                semanticReasons.push(`âš  ${conflict.desc} gedetecteerd`);
              }
            });

            score += Math.max(0, Math.min(15, semanticScore));

            const finalScore = Math.round((score / maxScore) * 100);
            
            return {
              score: finalScore,
              reasoning: reasoningFactors,
              maxScore,
              actualScore: score,
              semanticScore: semanticScore,
              semanticReasons: semanticReasons
            };
          }, []);

          const findMatches = useCallback((dealId) => {
            const deal = deals.find(d => d.id === dealId);
            if (!deal) return [];

            return investors.map(investor => {
              const matchResult = calculateMatchScore(investor, deal);
              return {
                investor,
                deal,
                matchScore: matchResult.score,
                reasoning: matchResult.reasoning,
                semanticScore: matchResult.semanticScore,
                semanticReasons: matchResult.semanticReasons,
                aiInsights: null
              };
            }).sort((a, b) => b.matchScore - a.matchScore);
          }, [deals, investors, calculateMatchScore]);

          // ðŸš€ PERFORMANCE: Memoized commission summary
          const calculateCommissionSummary = useMemo(() => {
            if (!user) return { totalCommission: 0, completedTransactions: 0, pendingTransactions: 0, totalVolume: 0 };
            
            const userTransactions = transactions.filter(t => {
              if (t.participant_commissions) {
                try {
                  const participants = JSON.parse(t.participant_commissions);
                  return participants.some(p => p.user_id === user.id);
                } catch (e) {
                  return false;
                }
              }
              return t.deal_owner_id === user.id || t.investor_owner_id === user.id;
            });
            
            const totalCommission = userTransactions.reduce((sum, t) => {
              if (t.participant_commissions) {
                try {
                  const participants = JSON.parse(t.participant_commissions);
                  const userParticipant = participants.find(p => p.user_id === user.id);
                  return sum + (userParticipant ? userParticipant.commission_amount : 0);
                } catch (e) {
                  return sum;
                }
              }
              const userCommission = t.deal_owner_id === user.id ? (t.deal_owner_commission || 0) : (t.investor_owner_commission || 0);
              return sum + userCommission;
            }, 0);

            const completedTransactions = userTransactions.filter(t => t.status === 'completed');
            const pendingTransactions = userTransactions.filter(t => t.status === 'pending');

            return {
              totalCommission,
              completedTransactions: completedTransactions.length,
              pendingTransactions: pendingTransactions.length,
              totalVolume: userTransactions.reduce((sum, t) => sum + (t.transaction_amount || 0), 0)
            };
          }, [transactions, user]);

          // AI Analysis Functions
          const getInvestorInsights = useCallback(async (investorId) => {
            const investor = investors.find(i => i.id === investorId);
            if (!investor) return;
            
            setIsLoadingAI(true);
            
            const detailedPrompt = `
DIEPGAANDE INVESTEERDER ANALYSE voor ${investor.naam}:

BASISGEGEVENS:
- Naam: ${investor.naam}
- Bedrijf: ${investor.bedrijf}
- Budget: â‚¬${investor.minBudget.toLocaleString()} - â‚¬${investor.maxBudget.toLocaleString()}
- Gewenst rendement: ${investor.gewenstRendement}%
- Risicoprofiel: ${investor.risicoprofiel}
- Ervaring: ${investor.ervaringLevel}
- Voorkeursregio's: ${investor.voorkeursRegio?.join(', ')}
- Voorkeurslanden: ${investor.voorkeursLanden?.join(', ')}
- Locatie details: ${investor.locatieDetails || 'Niet opgegeven'}
- Vastgoedtypes: ${investor.vastgoedTypes?.join(', ')}
- Project types: ${investor.projectTypes?.join(', ')}
- Communicatie voorkeur: ${investor.communicatieVoorkeur}
- Beschikbaarheid: ${investor.beschikbaarheid}

MOTIVATIE & BIJZONDERHEDEN:
- Investment motivatie: ${investor.investmentMotivatie || 'Niet opgegeven'}
- Bijzonderheden: ${investor.bijzonderheden || 'Niet opgegeven'}

ANALYSEER DIEPGAAND:
1. FinanciÃ«le sterkte en capaciteit
2. Psychologisch profiel en gedrag op basis van motivatie
3. Optimale deal karakteristieken
4. Risico tolerantie analyse
5. Onderhandelingsstrategie
6. Timing en marktsentiment
7. Concrete actie aanbevelingen

Geef een professionele, gedetailleerde analyse in Nederlandse taal.
            `;
            
            const insights = await callOpenAI(detailedPrompt, 'investor_analysis', investor);
            setAiInsights(prev => ({
              ...prev,
              [`investor_${investorId}`]: insights
            }));
          }, [investors, callOpenAI]);

          const getDealInsights = useCallback(async (dealId) => {
            const deal = deals.find(d => d.id === dealId);
            if (!deal) return;
            
            setIsLoadingAI(true);
            
            const detailedPrompt = `
DIEPGAANDE VASTGOED DEAL ANALYSE voor ${deal.titel}:

DEAL GEGEVENS:
- Titel: ${deal.titel}
- Bedrijf/Fonds: ${deal.bedrijfFonds || 'Niet opgegeven'}
- Locatie: ${deal.locatie}
- Type: ${deal.type}
- Project type: ${deal.projectType}
- Prijs: â‚¬${deal.prijs.toLocaleString()}
- Verwacht rendement: ${deal.verwachtRendement}%
- Risico: ${deal.risico}
- Oppervlakte: ${deal.oppervlakte}mÂ²
- Bouwjaar: ${deal.bouwjaar}
- Huurpotentie: â‚¬${deal.huurpotentie}

BESCHRIJVING & DETAILS:
- Beschrijving: ${deal.beschrijving}
- Bijzonderheden: ${deal.bijzonderheden || 'Niet opgegeven'}
- Contactpersoon: ${deal.contactpersoon || 'Niet opgegeven'}

ANALYSEER DIEPGAAND:
1. Marktpositie en concurrentie analyse
2. FinanciÃ«le projectie en cashflow
3. Risicofactoren en mitigation
4. Groei- en waardecreatiekansen
5. Locatie trends en demografische analyse
6. Vergelijking met vergelijkbare objecten
7. Aanbevelingen voor potentiÃ«le kopers
8. Optimale verkoop- en marketingstrategie

Geef een professionele, gedetailleerde analyse in Nederlandse taal met concrete cijfers en aanbevelingen.
            `;
            
            const insights = await callOpenAI(detailedPrompt, 'deal_analysis', deal);
            setAiInsights(prev => ({
              ...prev,
              [`deal_${dealId}`]: insights
            }));
          }, [deals, callOpenAI]);

          const getSmartMatchingInsights = useCallback(async (dealId, investorId) => {
            const deal = deals.find(d => d.id === dealId);
            const investor = investors.find(i => i.id === investorId);
            if (!deal || !investor) return;
            
            setIsLoadingAI(true);
            
            const detailedPrompt = `
ðŸ¤– GEAVANCEERDE AI SEMANTIC MATCHING ANALYSE:

DEAL: ${deal.titel}
- Bedrijf/Fonds: ${deal.bedrijfFonds || 'Niet opgegeven'}
- Locatie: ${deal.locatie}
- Type: ${deal.type} (${deal.projectType})
- Prijs: â‚¬${deal.prijs.toLocaleString()}
- Rendement: ${deal.verwachtRendement}%
- Risico: ${deal.risico}
- Deal beschrijving: "${deal.beschrijving}"
- Deal bijzonderheden: "${deal.bijzonderheden || 'Geen'}"

INVESTEERDER: ${investor.naam}
- Bedrijf: ${investor.bedrijf || 'Niet opgegeven'}
- Budget: â‚¬${investor.minBudget.toLocaleString()} - â‚¬${investor.maxBudget.toLocaleString()}
- Gewenst rendement: ${investor.gewenstRendement}%
- Risicoprofiel: ${investor.risicoprofiel}
- Ervaring: ${investor.ervaringLevel}
- Voorkeuren: ${investor.vastgoedTypes?.join(', ')}
- Locatie details: "${investor.locatieDetails || 'Geen specifieke eisen'}"
- Investment motivatie: "${investor.investmentMotivatie || 'Niet opgegeven'}"
- Bijzonderheden: "${investor.bijzonderheden || 'Geen'}"

ðŸŽ¯ VOER SEMANTIC MATCHING UIT:

1. SEMANTIC ANALYSE van deal beschrijving vs investeerder motivatie
   - Zoek naar overlappende concepten, synoniemen, gerelateerde termen
   - Bijvoorbeeld: "stabiele huurinkomsten" â†” "gegarandeerde huurder"
   - Bijvoorbeeld: "geen renovatie" â†” "turn-key" 
   - Bijvoorbeeld: "duurzaamheid" â†” "energielabel A"

2. CONFLICT DETECTIE
   - Zoek naar tegenstrijdigheden tussen wensen en aanbod
   - Bijvoorbeeld: "geen renovatie" vs "renovatie project"

3. COMPATIBILITY SCORE (0-100)
   - Combineer traditionele factoren + semantic matching
   - Geef uitleg per component

4. GEPERSONALISEERDE PITCH STRATEGIE
   - Welke aspecten van de deal benadrukken?
   - Hoe deal presenteren aan deze specifieke investeerder?
   - Welke voordelen matchen met hun motivatie?

5. SUCCESS PROBABILITY & TIMING
   - Kans op succesvolle deal
   - Optimaal moment voor approach

Geef concrete, actionable aanbevelingen voor deze specifieke match.
            `;
            
            const insights = await callOpenAI(detailedPrompt, 'enhanced_matching', { deal, investor });
            setAiInsights(prev => ({
              ...prev,
              [`enhanced_match_${dealId}_${investorId}`]: insights
            }));
          }, [deals, investors, callOpenAI]);

          const testAIConnection = useCallback(async () => {
            setIsLoadingAI(true);
            try {
              const response = await fetch('/.netlify/functions/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                  prompt: "Test connectie", 
                  type: 'connection_test', 
                  data: { test: true } 
                })
              });
              
              if (response.ok) {
                const result = await response.json();
                alert('âœ… AI Connectie ACTIEF!\n\nOpenAI Response ontvangen:\n' + (result.data?.fullAnalysis || result.data?.analysis || 'Connectie werkt!'));
                return true;
              } else {
                alert('âŒ AI Connectie FAILED!\n\nStatus: ' + response.status + '\nFallback naar demo data actief.');
                return false;
              }
            } catch (error) {
              alert('âŒ AI Connectie ERROR!\n\nFout: ' + error.message + '\nFallback naar demo data actief.');
              return false;
            } finally {
              setIsLoadingAI(false);
            }
          }, []);

          // CSV Upload Functions
          const handleCsvUpload = useCallback((event) => {
            const file = event.target.files[0];
            if (!file) return;

            Papa.parse(file, {
              header: true,
              skipEmptyLines: true,
              complete: function(results) {
                console.log('ðŸ“„ CSV geparsed:', results.data);
                
                const processedData = results.data.map((row, index) => ({
                  id: `csv_${Date.now()}_${index}`,
                  firstName: row['First Name'] || row['first_name'] || row['naam'] || '',
                  lastName: row['Last Name'] || row['last_name'] || row['achternaam'] || '',
                  fullName: (row['First Name'] || '') + ' ' + (row['Last Name'] || ''),
                  email: row['Email Address'] || row['email'] || row['e-mail'] || '',
                  company: row['Company'] || row['company'] || row['bedrijf'] || '',
                  position: row['Position'] || row['position'] || row['functie'] || '',
                  linkedin: row['URL'] || row['linkedin'] || row['LinkedIn URL'] || '',
                  phone: row['Phone'] || row['phone'] || row['telefoon'] || '',
                  location: row['Location'] || row['location'] || row['locatie'] || '',
                  notes: row['Notes'] || row['notes'] || row['opmerkingen'] || '',
                  source: 'csv_upload',
                  uploadedAt: new Date().toISOString(),
                  isConverted: false,
                  convertedTo: null,
                  owner_id: user.id
                })).filter(contact => contact.firstName || contact.lastName || contact.email);
                
                // ðŸ”§ DEDUPLICATION: Apply deduplication to CSV data
                const deduplicatedData = deduplicateByEmail(processedData);
                
                setCsvData(deduplicatedData);
                setShowCsvUpload(true);
              },
              error: function(error) {
                console.error('âŒ CSV parse error:', error);
                alert('Fout bij lezen CSV bestand: ' + error.message);
              }
            });
          }, [user, deduplicateByEmail]);

          const uploadContactsToFirebase = useCallback(async () => {
            if (!csvData.length) {
              alert('Geen contacten om te uploaden');
              return;
            }

            setIsUploadingCsv(true);
            
            try {
              console.log('ðŸ’¾ Uploading contacts to Firebase...');
              
              const batch = db.batch();
              
              csvData.forEach(contact => {
                const docRef = db.collection('contacts').doc();
                batch.set(docRef, {
                  ...contact,
                  id: docRef.id,
                  created_at: firebase.firestore.FieldValue.serverTimestamp()
                });
              });
              
              await batch.commit();
              
              // Update local state
              setRawContacts(prev => [...prev, ...csvData.map(contact => ({
                ...contact,
                created_at: new Date().toISOString()
              }))]);
              
              setCsvData([]);
              setShowCsvUpload(false);
              
              console.log('âœ… Contacts uploaded to Firebase');
              alert(`âœ… ${csvData.length} contacten succesvol geÃ¼pload!`);
            } catch (error) {
              console.error('âŒ Error uploading contacts:', error);
              alert('Fout bij uploaden contacten: ' + error.message);
            } finally {
              setIsUploadingCsv(false);
            }
          }, [csvData]);

          const convertContactToInvestor = useCallback(async (contact) => {
            try {
              console.log('ðŸ”„ Converting contact to investor:', contact.id);
              
              const investorData = {
                naam: contact.fullName || `${contact.firstName} ${contact.lastName}`.trim(),
                email: contact.email,
                telefoon: contact.phone || '',
                bedrijf: contact.company || '',
                locatie: contact.location || '',
                minBudget: 0,
                maxBudget: 0,
                voorkeursRegio: [],
                voorkeursLanden: [],
                locatieDetails: '',
                vastgoedTypes: [],
                projectTypes: [],
                risicoprofiel: 'Gemiddeld',
                gewenstRendement: 0,
                investeringshorizon: 'Middellang',
                ervaringLevel: 'Gemiddeld',
                investmentMotivatie: contact.notes || '',
                bijzonderheden: `Geconverteerd van contact. Positie: ${contact.position}`,
                communicatieVoorkeur: 'Email',
                beschikbaarheid: 'Direct',
                owner_id: user.id,
                convertedFrom: contact.id,
                created_at: firebase.firestore.FieldValue.serverTimestamp()
              };
              
              const docRef = await db.collection('investors').add(investorData);
              
              // Update contact as converted
              await db.collection('contacts').doc(contact.id).update({
                isConverted: true,
                convertedTo: 'investor',
                convertedId: docRef.id,
                convertedAt: firebase.firestore.FieldValue.serverTimestamp()
              });
              
              // Update local state
              setRawInvestors(prev => [...prev, { id: docRef.id, ...investorData, created_at: new Date().toISOString() }]);
              setRawContacts(prev => prev.map(c => 
                c.id === contact.id ? { ...c, isConverted: true, convertedTo: 'investor' } : c
              ));
              
              console.log('âœ… Contact converted to investor:', docRef.id);
              alert('âœ… Contact succesvol geconverteerd naar investeerder!');
            } catch (error) {
              console.error('âŒ Error converting contact to investor:', error);
              alert('Fout bij converteren naar investeerder: ' + error.message);
            }
          }, [user]);

          const convertContactToBroker = useCallback(async (contact) => {
            try {
              console.log('ðŸ”„ Converting contact to broker:', contact.id);
              
              const brokerData = {
                naam: contact.fullName || `${contact.firstName} ${contact.lastName}`.trim(),
                email: contact.email,
                telefoon: contact.phone || '',
                bedrijf: contact.company || '',
                locatie: contact.location || '',
                specialisaties: [],
                werkgebied: [],
                ervaringJaren: 0,
                trackRecord: contact.notes || '',
                commissieStructuur: '',
                locatieDetails: '',
                werkwijze: `Geconverteerd van contact. Positie: ${contact.position}`,
                bijzonderheden: '',
                owner_id: user.id,
                convertedFrom: contact.id,
                import_source: 'contact_conversion',
                created_at: firebase.firestore.FieldValue.serverTimestamp()
              };
              
              const docRef = await db.collection('brokers').add(brokerData);
              
              // Update contact as converted
              await db.collection('contacts').doc(contact.id).update({
                isConverted: true,
                convertedTo: 'broker',
                convertedId: docRef.id,
                convertedAt: firebase.firestore.FieldValue.serverTimestamp()
              });
              
              // Update local state
              setRawBrokers(prev => [...prev, { id: docRef.id, ...brokerData, created_at: new Date().toISOString() }]);
              setRawContacts(prev => prev.map(c => 
                c.id === contact.id ? { ...c, isConverted: true, convertedTo: 'broker' } : c
              ));
              
              console.log('âœ… Contact converted to broker:', docRef.id);
              alert('âœ… Contact succesvol geconverteerd naar broker!');
            } catch (error) {
              console.error('âŒ Error converting contact to broker:', error);
              alert('Fout bij converteren naar broker: ' + error.message);
            }
          }, [user]);

          const deleteContact = useCallback(async (contactId) => {
            if (confirm('Weet je zeker dat je dit contact wilt verwijderen?')) {
              try {
                console.log('ðŸ—‘ï¸ Deleting contact from Firebase...');
                
                await db.collection('contacts').doc(contactId).delete();
                setRawContacts(prev => prev.filter(c => c.id !== contactId));
                
                console.log('âœ… Contact deleted from Firebase:', contactId);
                alert('âœ… Contact succesvol verwijderd!');
              } catch (error) {
                console.error('âŒ Error deleting contact:', error);
                alert('Fout bij verwijderen contact: ' + error.message);
              }
            }
          }, []);

          const getContactClassification = useCallback(async (contact) => {
            const prompt = `
CONTACT CLASSIFICATIE ANALYSE:

CONTACT GEGEVENS:
- Naam: ${contact.fullName}
- Bedrijf: ${contact.company}
- Positie: ${contact.position}
- Email: ${contact.email}
- LinkedIn: ${contact.linkedin}
- Notities: ${contact.notes}

ANALYSEER en bepaal of dit contact:
1. INVESTOR is (vastgoedinvesteerder, fund manager, family office, etc.)
2. BROKER is (makelaar, vastgoed agent, deal sourcer, etc.)
3. BEIDE kan zijn
4. ONDUIDELIJK is

Geef aanbeveling met confidence score en redenering.
            `;
            
            return await callOpenAI(prompt, 'contact_classification', contact);
          }, [callOpenAI]);

          // Commission Management Functions
          const openCommissionEditor = useCallback((deal) => {
            setEditingDealCommission(deal);
            setShowCommissionEditor(true);
          }, []);

          const saveCommissionStructure = useCallback(async (dealId, commissionStructure) => {
            try {
              console.log('ðŸ’¾ Saving commission structure for deal:', dealId);
              
              await db.collection('deals').doc(dealId).update({
                commissionStructure: commissionStructure,
                updated_at: firebase.firestore.FieldValue.serverTimestamp()
              });
              
              setRawDeals(prev => prev.map(deal => 
                deal.id === dealId ? { ...deal, commissionStructure } : deal
              ));
              
              console.log('âœ… Commission structure saved');
              alert('âœ… Commissie structuur succesvol opgeslagen!');
            } catch (error) {
              console.error('âŒ Error saving commission structure:', error);
              alert('Fout bij opslaan commissie structuur: ' + error.message);
            }
          }, []);

          const createTransaction = useCallback(async (dealId, investorId) => {
            const deal = deals.find(d => d.id === dealId);
            const investor = investors.find(i => i.id === investorId);
            
            if (!deal || !investor) return;

            const commissionStructure = deal.commissionStructure || {
              total_rate: 0.025,
              participants: [
                { 
                  role: 'deal_owner', 
                  user_id: deal.owner_id, 
                  percentage: 60, 
                  fixed_amount: 0, 
                  type: 'percentage',
                  name: getUserById(deal.owner_id).name,
                  is_external: false
                },
                { 
                  role: 'investor_referral', 
                  user_id: investor.owner_id, 
                  percentage: 40, 
                  fixed_amount: 0, 
                  type: 'percentage',
                  name: getUserById(investor.owner_id).name,
                  is_external: false
                }
              ]
            };

            const totalCommission = deal.prijs * commissionStructure.total_rate;
            
            const participantCommissions = commissionStructure.participants.map(participant => {
              let commission = 0;
              if (participant.type === 'percentage') {
                commission = totalCommission * (participant.percentage / 100);
              } else if (participant.type === 'fixed') {
                commission = participant.fixed_amount;
              }
              return {
                ...participant,
                commission_amount: commission
              };
            });

            const transactionData = {
              id: Date.now().toString(),
              deal_id: dealId,
              investor_id: investorId,
              deal_owner_id: deal.owner_id,
              investor_owner_id: investor.owner_id,
              transaction_amount: deal.prijs,
              commission_rate: commissionStructure.total_rate,
              total_commission: totalCommission,
              commission_structure: JSON.stringify(commissionStructure),
              participant_commissions: JSON.stringify(participantCommissions),
              status: 'pending',
              closed_date: null,
              created_at: new Date().toISOString()
            };

            try {
              await db.collection('transactions').add(transactionData);
              setRawTransactions(prev => [...prev, transactionData]);
              
              console.log('âœ… Transaction created:', transactionData);
              alert('âœ… Transactie succesvol aangemaakt! Ga naar "Transacties" tab om de details te bekijken.');
              setActiveTab('transactions');
            } catch (error) {
              console.error('âŒ Error creating transaction:', error);
              alert('Fout bij aanmaken transactie: ' + error.message);
            }
          }, [deals, investors, getUserById]);

          // Data Loading Functions
          const loadData = useCallback(async () => {
            if (!user) return;
            
            try {
              console.log('ðŸ“Š Loading data from Firebase...');
              
              // ðŸš€ PERFORMANCE: Load all collections in parallel
              const [usersSnapshot, investorsSnapshot, brokersSnapshot, dealsSnapshot, transactionsSnapshot, contactsSnapshot] = await Promise.all([
                db.collection('users').get(),
                db.collection('investors').get(),
                db.collection('brokers').get(),
                db.collection('deals').get(),
                db.collection('transactions').get(),
                db.collection('contacts').get()
              ]);
              
              const usersData = usersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
              const investorsData = investorsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
              const brokersData = brokersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
              const dealsData = dealsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
              const transactionsData = transactionsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
              const contactsData = contactsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
              
              // Set raw data (will be deduplicated by memoized computations)
              setRawUsers(usersData);
              setRawInvestors(investorsData);
              setRawBrokers(brokersData);
              setRawDeals(dealsData);
              setRawTransactions(transactionsData);
              setRawContacts(contactsData);
              
              console.log('âœ… Data loaded from Firebase:', {
                users: usersData.length,
                investors: investorsData.length,
                brokers: brokersData.length,
                deals: dealsData.length,
                transactions: transactionsData.length,
                contacts: contactsData.length
              });
              
            } catch (error) {
              console.error('âŒ Error loading data from Firebase:', error);
              console.log('ðŸ“‹ Loading demo data as fallback...');
              await loadDemoData();
            }
          }, [user]);

          const loadDemoData = useCallback(async () => {
            console.log('ðŸŽ­ Loading demo data...');
            
            const demoUsers = [
              { id: user.id, name: user.name, email: user.email, company: user.company, role: user.role || 'agent' }
            ];

            const demoInvestors = [
              {
                id: 'demo1',
                naam: 'Peter van der Berg',
                email: 'peter@example.com',
                telefoon: '06-12345678',
                bedrijf: 'Berg Investments',
                locatie: 'Amsterdam',
                minBudget: 100000,
                maxBudget: 500000,
                voorkeursLanden: ['Nederland', 'Duitsland'],
                voorkeursRegio: ['West-Europa'],
                locatieDetails: 'Amsterdam centrum bij de ring, nabij openbaar vervoer. Liever geen Zuidoost of Noord.',
                vastgoedTypes: ['Appartement', 'Kantoor'],
                projectTypes: ['Turn-key', 'Renovatie'],
                risicoprofiel: 'Gemiddeld',
                gewenstRendement: 6,
                investeringshorizon: 'Lang termijn',
                ervaringLevel: 'Ervaren',
                beschikbaarheid: 'Direct',
                communicatieVoorkeur: 'Telefoon',
                investmentMotivatie: 'Zoek stabiele huurinkomsten voor pensioenopbouw. Geen renovatie projecten, liever turn-key appartementen. Ervaring met studentenhuisvesting. Duurzaamheid steeds belangrijker.',
                bijzonderheden: 'Heeft voorkeur voor energiezuinige panden. Geen ground floor retail. Ervaring met vastgoedbeheer.',
                owner_id: user.id,
                created_at: new Date().toISOString()
              }
            ];

            const demoBrokers = [
              {
                id: 'broker1',
                naam: 'Sarah de Vries',
                email: 'sarah@vastgoedpro.nl',
                telefoon: '020-7654321',
                bedrijf: 'VastgoedPro Makelaars',
                locatie: 'Amsterdam',
                specialisaties: ['Commercieel', 'Kantoren', 'Retail'],
                werkgebied: ['Amsterdam', 'Haarlem', 'Almere'],
                ervaringJaren: 8,
                trackRecord: 'Gespecialiseerd in commercieel vastgoed â‚¬500K-â‚¬5M. 120+ deals afgelopen 5 jaar. Focus op kantoorpanden en retail.',
                commissieStructuur: '2.5% koper, 2.5% verkoper. Exclusieve deals 3%.',
                locatieDetails: 'Actief in Randstad, specialiteit Amsterdam Noord en Zuidas.',
                werkwijze: 'Proactieve deal sourcing, uitgebreid netwerk van investeerders. Snelle besluitvorming, transparante communicatie.',
                bijzonderheden: 'Spreekt vloeiend Engels en Duits. Ervaring met internationale investeerders. RICS gecertificeerd.',
                import_source: 'manual',
                owner_id: user.id,
                created_at: new Date().toISOString()
              }
            ];

            const demoContacts = [
              {
                id: 'contact1',
                firstName: 'Michael',
                lastName: 'Johnson',
                fullName: 'Michael Johnson',
                email: 'michael.johnson@realestatefund.com',
                company: 'European Real Estate Fund',
                position: 'Investment Director',
                linkedin: 'https://linkedin.com/in/michaeljohnson',
                phone: '+31-20-1234567',
                location: 'Amsterdam',
                notes: 'Focus on commercial real estate â‚¬1M+, interested in Netherlands and Germany markets',
                source: 'demo_data',
                uploadedAt: new Date().toISOString(),
                isConverted: false,
                convertedTo: null,
                owner_id: user.id,
                created_at: new Date().toISOString()
              },
              {
                id: 'contact2',
                firstName: 'Emma',
                lastName: 'Schmidt',
                fullName: 'Emma Schmidt',
                email: 'emma@berlinproperties.de',
                company: 'Berlin Properties GmbH',
                position: 'Senior Real Estate Agent',
                linkedin: 'https://linkedin.com/in/emmaSchmidt',
                phone: '+49-30-9876543',
                location: 'Berlin',
                notes: 'Specializes in residential and mixed-use developments. Strong network of international investors.',
                source: 'demo_data',
                uploadedAt: new Date().toISOString(),
                isConverted: false,
                convertedTo: null,
                owner_id: user.id,
                created_at: new Date().toISOString()
              }
            ];
            
            const demoDeals = [
              {
                id: 'demo1',
                titel: 'Modern Appartement Amsterdam',
                locatie: 'Amsterdam',
                type: 'Appartement',
                projectType: 'Turn-key',
                prijs: 350000,
                verwachtRendement: 5.5,
                risico: 'Gemiddeld',
                beschrijving: 'Kant-en-klaar nieuwbouw appartement in opkomende wijk Noord. Energielabel A, zonnepanelen, warmtepomp. Gegarandeerde huurder voor 5 jaar via corporatie. Nabij metro, 15 min naar centrum. Turn-key: direct rendement, geen werk aan.',
                oppervlakte: 85,
                bouwjaar: 2020,
                huurpotentie: 1800,
                status: 'Beschikbaar',
                bedrijfFonds: 'Demo Vastgoed B.V.',
                bijzonderheden: 'Duurzaam gebouwd, lage servicekosten. Professioneel beheer beschikbaar. Uitstekende buurt met goede voorzieningen.',
                contactpersoon: 'Maria Janssen',
                telefoon: '020-1234567',
                email: 'maria@demovastgoed.nl',
                isRelevant: true,
                ourScore: 8.5,
                aiAnalyzed: false,
                owner_id: user.id,
                created_at: new Date().toISOString(),
                commissionStructure: {
                  total_rate: 0.025,
                  participants: [
                    { 
                      role: 'deal_owner', 
                      user_id: user.id, 
                      percentage: 60, 
                      fixed_amount: 0, 
                      type: 'percentage',
                      name: user.name,
                      is_external: false
                    }
                  ]
                }
              }
            ];
            
            setRawUsers(demoUsers);
            setRawInvestors(demoInvestors);
            setRawBrokers(demoBrokers);
            setRawContacts(demoContacts);
            setRawDeals(demoDeals);
            setRawTransactions([]);
            
            try {
              await saveDemoDataToFirebase(demoInvestors, demoBrokers, demoDeals, demoContacts);
            } catch (error) {
              console.log('Could not save demo data to Firebase:', error);
            }
          }, [user]);
          
          const saveDemoDataToFirebase = useCallback(async (investors, brokers, deals, contacts) => {
            try {
              const batch = db.batch();
              
              investors.forEach(investor => {
                const docRef = db.collection('investors').doc(investor.id);
                batch.set(docRef, {
                  ...investor,
                  created_at: firebase.firestore.FieldValue.serverTimestamp()
                });
              });

              brokers.forEach(broker => {
                const docRef = db.collection('brokers').doc(broker.id);
                batch.set(docRef, {
                  ...broker,
                  created_at: firebase.firestore.FieldValue.serverTimestamp()
                });
              });

              contacts.forEach(contact => {
                const docRef = db.collection('contacts').doc(contact.id);
                batch.set(docRef, {
                  ...contact,
                  created_at: firebase.firestore.FieldValue.serverTimestamp()
                });
              });
              
              deals.forEach(deal => {
                const docRef = db.collection('deals').doc(deal.id);
                batch.set(docRef, {
                  ...deal,
                  created_at: firebase.firestore.FieldValue.serverTimestamp()
                });
              });
              
              await batch.commit();
              console.log('âœ… Demo data saved to Firebase');
            } catch (error) {
              console.error('âŒ Error saving demo data:', error);
            }
          }, []);

          // CRUD Functions
          const handleAddInvestor = useCallback(async (investorData) => {
            try {
              console.log('ðŸ’¾ Adding investor to Firebase...');
              
              const newInvestor = {
                ...investorData,
                minBudget: parseInt(investorData.minBudget) || 0,
                maxBudget: parseInt(investorData.maxBudget) || 0,
                gewenstRendement: parseFloat(investorData.gewenstRendement) || 0,
                owner_id: user.id,
                created_at: firebase.firestore.FieldValue.serverTimestamp()
              };
              
              const docRef = await db.collection('investors').add(newInvestor);
              
              const investorWithId = {
                id: docRef.id,
                ...newInvestor,
                created_at: new Date().toISOString()
              };
              
              setRawInvestors(prev => [...prev, investorWithId]);
              setShowAddInvestor(false);
              
              console.log('âœ… Investor added to Firebase:', docRef.id);
            } catch (error) {
              console.error('âŒ Error adding investor:', error);
              alert('Fout bij toevoegen investeerder: ' + error.message);
            }
          }, [user]);

          const handleAddBroker = useCallback(async (brokerData) => {
            try {
              console.log('ðŸ’¾ Adding broker to Firebase...');
              
              const newBroker = {
                ...brokerData,
                ervaringJaren: parseInt(brokerData.ervaringJaren) || 0,
                owner_id: user.id,
                import_source: 'manual',
                created_at: firebase.firestore.FieldValue.serverTimestamp()
              };
              
              const docRef = await db.collection('brokers').add(newBroker);
              
              const brokerWithId = {
                id: docRef.id,
                ...newBroker,
                created_at: new Date().toISOString()
              };
              
              setRawBrokers(prev => [...prev, brokerWithId]);
              setShowAddBroker(false);
              
              console.log('âœ… Broker added to Firebase:', docRef.id);
              alert('âœ… Broker succesvol toegevoegd!');
            } catch (error) {
              console.error('âŒ Error adding broker:', error);
              alert('Fout bij toevoegen broker: ' + error.message);
            }
          }, [user]);

          const handleAddDeal = useCallback(async (dealData) => {
            try {
              console.log('ðŸ’¾ Adding deal to Firebase...');
              
              const newDeal = {
                ...dealData,
                prijs: parseInt(dealData.prijs) || 0,
                verwachtRendement: parseFloat(dealData.verwachtRendement) || 0,
                oppervlakte: parseInt(dealData.oppervlakte) || 0,
                bouwjaar: parseInt(dealData.bouwjaar) || 0,
                huurpotentie: parseInt(dealData.huurpotentie) || 0,
                owner_id: user.id,
                commissionStructure: {
                  total_rate: 0.025,
                  participants: [
                    { 
                      role: 'deal_owner', 
                      user_id: user.id, 
                      percentage: 100, 
                      fixed_amount: 0, 
                      type: 'percentage',
                      name: user.name,
                      is_external: false
                    }
                  ]
                },
                created_at: firebase.firestore.FieldValue.serverTimestamp()
              };
              
              const docRef = await db.collection('deals').add(newDeal);
              
              const dealWithId = {
                id: docRef.id,
                ...newDeal,
                created_at: new Date().toISOString()
              };
              
              setRawDeals(prev => [...prev, dealWithId]);
              setShowAddDeal(false);
              
              console.log('âœ… Deal added to Firebase:', docRef.id);
            } catch (error) {
              console.error('âŒ Error adding deal:', error);
              alert('Fout bij toevoegen deal: ' + error.message);
            }
          }, [user]);

          const handleEditInvestor = useCallback((investor) => {
            setEditingInvestor(investor);
            setShowEditInvestor(true);
          }, []);

          const handleEditDeal = useCallback((deal) => {
            setEditingDeal(deal);
            setShowEditDeal(true);
          }, []);

          const handleEditBroker = useCallback((broker) => {
            setEditingBroker(broker);
            setShowEditBroker(true);
          }, []);

          const handleUpdateInvestor = useCallback(async (investorData) => {
            try {
              console.log('ðŸ’¾ Updating investor in Firebase...', editingInvestor.id);
              
              const updatedInvestor = {
                ...investorData,
                minBudget: parseInt(investorData.minBudget) || 0,
                maxBudget: parseInt(investorData.maxBudget) || 0,
                gewenstRendement: parseFloat(investorData.gewenstRendement) || 0,
                updated_at: firebase.firestore.FieldValue.serverTimestamp()
              };
              
              await db.collection('investors').doc(editingInvestor.id).update(updatedInvestor);
              
              setRawInvestors(prev => prev.map(inv => 
                inv.id === editingInvestor.id ? { ...inv, ...updatedInvestor } : inv
              ));
              
              setShowEditInvestor(false);
              setEditingInvestor(null);
              
              console.log('âœ… Investor updated in Firebase:', editingInvestor.id);
              alert('âœ… Investeerder succesvol bijgewerkt!');
            } catch (error) {
              console.error('âŒ Error updating investor:', error);
              alert('Fout bij bijwerken investeerder: ' + error.message);
            }
          }, [editingInvestor]);

          const handleUpdateDeal = useCallback(async (dealData) => {
            try {
              console.log('ðŸ’¾ Updating deal in Firebase...', editingDeal.id);
              
              const updatedDeal = {
                ...dealData,
                prijs: parseInt(dealData.prijs) || 0,
                verwachtRendement: parseFloat(dealData.verwachtRendement) || 0,
                oppervlakte: parseInt(dealData.oppervlakte) || 0,
                bouwjaar: parseInt(dealData.bouwjaar) || 0,
                huurpotentie: parseInt(dealData.huurpotentie) || 0,
                commissionStructure: editingDeal.commissionStructure,
                updated_at: firebase.firestore.FieldValue.serverTimestamp()
              };
              
              await db.collection('deals').doc(editingDeal.id).update(updatedDeal);
              
              setRawDeals(prev => prev.map(deal => 
                deal.id === editingDeal.id ? { ...deal, ...updatedDeal } : deal
              ));
              
              setShowEditDeal(false);
              setEditingDeal(null);
              
              console.log('âœ… Deal updated in Firebase:', editingDeal.id);
              alert('âœ… Deal succesvol bijgewerkt!');
            } catch (error) {
              console.error('âŒ Error updating deal:', error);
              alert('Fout bij bijwerken deal: ' + error.message);
            }
          }, [editingDeal]);

          const handleUpdateBroker = useCallback(async (brokerData) => {
            try {
              console.log('ðŸ’¾ Updating broker in Firebase...', editingBroker.id);
              
              const updatedBroker = {
                ...brokerData,
                ervaringJaren: parseInt(brokerData.ervaringJaren) || 0,
                updated_at: firebase.firestore.FieldValue.serverTimestamp()
              };
              
              await db.collection('brokers').doc(editingBroker.id).update(updatedBroker);
              
              setRawBrokers(prev => prev.map(broker => 
                broker.id === editingBroker.id ? { ...broker, ...updatedBroker } : broker
              ));
              
              setShowEditBroker(false);
              setEditingBroker(null);
              
              console.log('âœ… Broker updated in Firebase:', editingBroker.id);
              alert('âœ… Broker succesvol bijgewerkt!');
            } catch (error) {
              console.error('âŒ Error updating broker:', error);
              alert('Fout bij bijwerken broker: ' + error.message);
            }
          }, [editingBroker]);

          const handleDeleteInvestor = useCallback(async (investorId) => {
            if (confirm('Weet je zeker dat je deze investeerder wilt verwijderen?')) {
              try {
                console.log('ðŸ—‘ï¸ Deleting investor from Firebase...');
                
                await db.collection('investors').doc(investorId).delete();
                setRawInvestors(prev => prev.filter(i => i.id !== investorId));
                
                console.log('âœ… Investor deleted from Firebase:', investorId);
              } catch (error) {
                console.error('âŒ Error deleting investor:', error);
                alert('Fout bij verwijderen investeerder: ' + error.message);
              }
            }
          }, []);

          const handleDeleteDeal = useCallback(async (dealId) => {
            if (confirm('Weet je zeker dat je deze deal wilt verwijderen?\n\nLet op: Gerelateerde transacties worden ook verwijderd.')) {
              try {
                console.log('ðŸ—‘ï¸ Deleting deal from Firebase...');
                
                const relatedTransactions = transactions.filter(t => t.deal_id === dealId);
                for (const transaction of relatedTransactions) {
                  await db.collection('transactions').doc(transaction.id).delete();
                }
                
                await db.collection('deals').doc(dealId).delete();
                
                setRawDeals(prev => prev.filter(d => d.id !== dealId));
                setRawTransactions(prev => prev.filter(t => t.deal_id !== dealId));
                
                console.log('âœ… Deal deleted from Firebase:', dealId);
                alert('âœ… Deal succesvol verwijderd!');
              } catch (error) {
                console.error('âŒ Error deleting deal:', error);
                alert('Fout bij verwijderen deal: ' + error.message);
              }
            }
          }, [transactions]);

          const handleDeleteBroker = useCallback(async (brokerId) => {
            if (confirm('Weet je zeker dat je deze broker wilt verwijderen?')) {
              try {
                console.log('ðŸ—‘ï¸ Deleting broker from Firebase...');
                
                await db.collection('brokers').doc(brokerId).delete();
                setRawBrokers(prev => prev.filter(b => b.id !== brokerId));
                
                console.log('âœ… Broker deleted from Firebase:', brokerId);
                alert('âœ… Broker succesvol verwijderd!');
              } catch (error) {
                console.error('
